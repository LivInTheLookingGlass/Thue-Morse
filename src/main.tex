\documentclass[conference]{IEEEtran}
\input{macros}
\begin{document}

\title{Extending The \TMS}

\author{\IEEEauthorblockN{Olivia Appleton-Crocker}
\IEEEauthorblockA{\textit{TMW Center for Early Learning + Public Health}\\
\textit{University of Chicago}\\
Chicago, Illinois, United States\\
ORCID: 0009-0004-2296-7033}
\and
\IEEEauthorblockN{Dan Rowe}
\IEEEauthorblockA{\textit{Department of Math and Computer Science}\\
Northern Michigan University\\
Marquette, Michigan, United States\\
Email: darowe@nmu.edu}
}

\maketitle

\begin{abstract}
In this paper, we discuss various ways to extend the \TMS \cite{OEIS-TMS} when used as a fair-share sequence. Included are \TotalOriginals definitions of the original sequence, \TotalExtensions extensions to n players, and proofs of equality for all definitions. In the appendix are several complexity analyses for both time and space of each definition.
\end{abstract}

\begin{IEEEkeywords}
TBA
\end{IEEEkeywords}

\section{Introduction}

\note{Make sure to add that while this paper does not deal with negative or fractional bases, many of the definitions are trivially extendable to that domain, and at least one of them already has been in another paper.}

\note{All definitions are tested, though due to resource limitations, to different extents.}


\renewcommand{\arraystretch}{1.25}
\begin{table}[H]
\label{tab:testing_b2}
\caption{Extent of Testing in Base 2}
\centering
\begin{tabular}{|l|r|}
\hline
Definition & Extent of Testing            \\ \hline
$T_{2,1}$  &\multirow{2}{*}{$2^{35}=34,359,738,368$}\\ \cline{1-1}
$T_{2,2}$  &                              \\ \hline
$T_{2,3}$  & $2^{34} = 17,179,869,184$    \\ \hline
$T_{2,4}$  & $2^{33} = 17,179,869,184$    \\ \hline
$T_{2,5}$  &\multirow{2}{*}{$2^{32}=4,294,967,296$}\\ \cline{1-1}
$T_{2,6}$  &                              \\ \hline
$T_{2,7}$  & $2^{35} = 34,359,738,368$    \\ \hline
$T_{2,8}$  & $2^{26} = 67,108,864$        \\ \hline
$T_{2,9}$  &\multirow{4}{*}{$2^{35}=34,359,738,368$}\\ \cline{1-1}
$T_{2,10}$ &                              \\ \cline{1-1}
$T_{2,11}$ &                              \\ \cline{1-1}
$T_{2,12}$ &                              \\ \hline
$T_{2,13}$ & $2^{15} = 32,768$            \\ \hline
$T_{2,14}$ & $2^{29} = 536,870,912$       \\ \hline
$T_{n,1}$  &\multirow{2}{*}{$2^{33}=8,589,934,592$}\\ \cline{1-1}
$T_{n,2}$  &                              \\ \hline
$T_{n,3}$  &\multirow{2}{*}{$2^{32}=4,294,967,296$}\\ \cline{1-1}
$T_{n,4}$  &                              \\ \hline
$T_{n,5}$  & $2^{29} = 536,870,912$       \\ \hline
$T_{n,6}$  & $2^{32} = 4,294,967,296$     \\ \hline
$T_{n,7}$  & $2^{31} = 2,147,483,648$     \\ \hline
\end{tabular}
\end{table}

\begin{table}[H]
\label{tab:testing_bn}
\caption{Extent of Testing in Each Base}
\centering
\begin{tabular}{|l|c|r|}
\hline
\textbf{Definition}       & \textbf{Bases}         & \textbf{Entries Tested}              \\\hline
$T_{n,1}$                 &\multirow{2}{*}{3 - 256}& $2^{26} = 67,108,864$                \\\cline{1-1}\cline{3-3}
$T_{n,2}$                 &                        &\multirow{2}{*}{$2^{25} = 33,554,432$}\\\cline{1-2}
\multirow{2}{*}{$T_{n,3}$}& 3 - 192                &                                      \\\cline{2-3} 
                          & 193 - 256              & $2^{24} = 16,777,216$                \\\hline
$T_{n,4}$                 & 3 - 256                & $2^{25} = 33,554,432$                \\\hline
\multirow{2}{*}{$T_{n,5}$}& 3 - 192                & $2^{24} = 16,777,216$                \\\cline{2-3} 
                          & 193 - 256              & $2^{23} = 8,388,608$                 \\\hline
$T_{n,6}$                 &\multirow{2}{*}{3 - 256}&\multirow{2}{*}{$2^{26} = 67,108,864$}\\\cline{1-1}
$T_{n,7}$                 &                        &                                      \\\hline
\end{tabular}
\end{table}

\begin{table}[H]
\label{tab:comparison-b2}
\centering
\caption{Comparison Matrix of the Standard Definitions}
\note{X = done, O = target} \\
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\cline{1-1}
\!\!\!\!$T_{2,1}$\!\!\!\!\\ \cline{1-2}
    O    &\!\!\!\!$T_{2,2}$\!\!\!\!\\ \cline{1-3}
         &         &\!\!\!\!$T_{2,3}$\!\!\!\!\\ \cline{1-4}
         &         &         &\!\!\!\!$T_{2,4}$\!\!\!\!\\ \cline{1-5}
          &         &         &    O    &\!\!\!\!$T_{2,5}$\!\!\!\!\\ \cline{1-6}
    X    &         &         &         &         &\!\!\!\!$T_{2,6}$\!\!\!\!\\ \cline{1-7}
         &         &         &         &         &         &\!\!\!\!$T_{2,7}$\!\!\!\!\\ \cline{1-8}
         &         &         &         &         &         &      O  &\!\!\!\!$T_{2,8}$\!\!\!\!\\ \cline{1-9}
         &         &         &         &         &         &         &         &\!\!\!\!$T_{2,9}$\!\!\!\!\\ \cline{1-10}
         &         &         &         &         &         &         &         &     O   &\!\!\!\!$T_{2,10}$\!\!\!\!\\ \cline{1-11}
         &         &         &         &         &         &         &         &         &         &\!\!\!\!$T_{2,11}$\!\!\!\!\\ \cline{1-12}
         &         &         &         &         &         &         &         &         &         &         &\!\!\!\!$T_{2,12}$\!\!\!\!\\ \cline{1-13}
         &         &         &         &         &         &         &         &         &         &         &         &\!\!\!\!$T_{2,13}$\!\!\!\!\\ \cline{1-14}
         &         &         &         &         &         &         &         &         &         &         &         &     &\!\!\!\!$T_{2,14}$\!\!\!\!\\ \hline
\end{tabular}
\end{table}

\begin{table}[H]
\label{tab:comparison-bn}
\centering
\caption{Comparison Matrix of the Extended Definitions}
\note{X = done, O = target} \\
\begin{tabular}{|c|c|c|c|c|c|c|}
\cline{1-1}
\!\!\!\!$T_{n,1}$\!\!\!\!\\ \cline{1-2}
    O    &\!\!\!\!$T_{n,2}$\!\!\!\!\\ \cline{1-3}
         &    O    &\!\!\!\!$T_{n,3}$\!\!\!\!\\ \cline{1-4}
         &         &    O     &\!\!\!\!$T_{n,4}$\!\!\!\!\\ \cline{1-5}
         &         &         &     O   &\!\!\!\!$T_{n,5}$\!\!\!\!\\ \cline{1-6}
    O    &         &         &         &         &\!\!\!\!$T_{n,6}$\!\!\!\!\\ \cline{1-7}
         &         &         &         &         &\!\!\!\!&      $T_{n,7}$\!\!\!\!\\ \hline
\end{tabular}
\end{table}

\renewcommand{\arraystretch}{1}

\section{The Original Sequence}

\subsection{Definition \arabic{stddefctr} of \TotalOriginals\xspace -- Parity of Hamming Weight}

\note{This definition appears in \cite{Spiegelhofer_2020, Allouche-Shallit_1999, OEIS-TMS}}

The Hamming Weight, as typically defined, is the digit sum of a binary number. In other words, it is a count of the high bits in a given number. A common way to generate the \TMS is to take the parity\footnote{Whether a number is odd or even} of the Hamming Weight\footnote{The count of $1$s in the binary representation of a number} for each natural number. We can define that as follows:

\begin{equation}
    \edef\tempLabel{eq:p2_d\arabic{stddefctr}}
    \label{\tempLabel}
    \begin{aligned}
      p(0) &= 0 \\
      p(n) &= n + p\left(\floor{\dfrac{n}{2}}\right) \pmod{2} \\
T_{2,\arabic{stddefctr}}(n) &= p(n)
    \end{aligned}
\end{equation}

The subscript indicates that we are using $2$ players (writing in base $2$) and that we are using the first definition laid out in this paper. Note that when we extend to n players, the $T$ function will get a second parameter for the number of players, so it will look like $T_{n,d}(x, s)$, where $s$ is the size of the player pool, and therefore the base we use to define the sequence.

\stepcounter{stddefctr}
\subsection{Definition \arabic{stddefctr} of \TotalOriginals\xspace -- Root of Unity}

\note{This appears in \cite{OEIS-TMS-inv}}

\begin{equation}
    \edef\tempLabel{eq:p2_d\arabic{stddefctr}}
    \label{\tempLabel}
    \begin{aligned}
T_{2,\arabic{stddefctr}}(n) &= \dfrac{1 - (-1)^{p(n)}}{2}
    \end{aligned}
\end{equation}

\stepcounter{stddefctr}
\subsection{Definition \arabic{stddefctr} of \TotalOriginals\xspace -- Invert and Extend}

\note{Appears in \cite{OEIS-TMS}}

This definition is more natural to think about as extending a tuple that contains the sequence. We will give a recurrence relation below, but to build an intuition we will work in this framework first.

Let $t(n)$ be the first $2^n$ elements of the \TMS. Given this, we can define:

\begin{equation}
\begin{aligned}
\text{inv}(\mathbf{x}) &= \begin{cases}
        0, & \text{if } x_i = 1 \\
        1, & \text{if } x_i = 0
    \end{cases} \\
    &\quad\quad\text{for } \mathbf{x} = \tuple{x_0, x_1, \ldots, x_{n-1}} \\
                  t(0) &= \tuple{0} \\
                  t(n) &= t(n - 1) \concat \text{inv}(t(n - 1))
    \end{aligned}
\end{equation}

Given the above, we can define a recurrence relation that will give us individual elements. It will be less efficient to compute, but will allow proofs of equivalence to be easier.

\note{Should the below have a +1 inside the log?}

\begin{equation}
    \edef\tempLabel{eq:p2_d\arabic{stddefctr}}
    \label{\tempLabel}
    \begin{aligned}
T_{2,\arabic{stddefctr}}(0) &= 0 \\
T_{2,\arabic{stddefctr}}(n) &= T_{2,\arabic{stddefctr}}\left(n - 2^{\floor{\log_2(n)}}\right) + 1 \pmod{2}
    \end{aligned}
\end{equation}

\stepcounter{stddefctr}
\subsection{Definition \arabic{stddefctr} of \TotalOriginals\xspace -- Substitute and Flatten}

\note{This definition appears in \cite{Spiegelhofer_2020, Kolář-Nori_1991, OEIS-TMS}}

\begin{equation}
    \edef\tempLabel{eq:p2_d\arabic{stddefctr}}
    \label{\tempLabel}
    \begin{aligned}
      s(n) &= \begin{cases}
          \tuple{0, 1}, & \text{if } n = 0 \\
          \tuple{1, 0}, & \text{if } n = 1
      \end{cases} \\
      t(0) &= \tuple{0} \\
      t(n) &= \bigparallel_{i=0}^{2^{n-1}-1} s(t(n-1)_i)  \\
T_{2,\arabic{stddefctr}}(n) &= t(\ceil{\log_2(n + 1)})_n
    \end{aligned}
\end{equation}

So for example, calculating $T_{2,3}(3)$ would look like:

\begin{equation}
    \begin{aligned}
      t(0) &= \tuple{0} \\
      t(1) &= \bigparallel_{i=0}^{0} s(t(0)_i) = \tuple{0, 1} \\
      t(2) &= \bigparallel_{i=0}^{1} s(t(1)_i) = \tuple{0, 1, 1, 0} \\
T_{2,\arabic{stddefctr}}(3) &= t(\ceil{\log_2(3 + 1)})_3 \\
           &= t(2)_3 \\
           &= \tuple{0, 1, 1, 0}_3 \\
           &= 0
    \end{aligned}
\end{equation}

\stepcounter{stddefctr}
\subsection{Definition \arabic{stddefctr} of \TotalOriginals\xspace -- Recursive Rotation}

Another way to phrase the above definition is as recursive rotation. If we decompose $s$, we can instead represent it as:

\begin{equation}
    \edef\tempLabel{eq:p2_d\arabic{stddefctr}}
    \label{\tempLabel}
    \begin{aligned}
r(\mathbf{x}, i) &= \begin{aligned}[c]
                   &\tuple{x_{0 + i \mod{|\mathbf{x}|}}, x_{1 + i \mod{|\mathbf{x}|}}, \ldots} \\
                   &\text{for } \mathbf{x} = \tuple{x_0, x_1, \ldots, x_{n-1}}
        \end{aligned} \\
            t(0) &= \tuple{0} \\
            t(1) &= \tuple{0, 1} \\
            t(n) &= \bigparallel_{i=0}^1 r\left(t(n-1), i \cdot 2^{n-2}\right) \\
      T_{2,\arabic{stddefctr}}(n) &= t(\ceil{\log_2(n + 1)})_n
    \end{aligned}
\end{equation}

\stepcounter{stddefctr}
\subsection{Definition \arabic{stddefctr} of \TotalOriginals\xspace -- Recursion}

\note{This definition appears in \cite{Kolář-Nori_1991, OEIS-TMS}}

\begin{equation}
    \edef\tempLabel{eq:p2_d\arabic{stddefctr}}
    \label{\tempLabel}
    \begin{aligned}
   T_{2,\arabic{stddefctr}}(0) &= 0 \\
  T_{2,\arabic{stddefctr}}(2n) &= T_{2,\arabic{stddefctr}}(n) \\
T_{2,\arabic{stddefctr}}(2n+1) &= 1 - T_{2,\arabic{stddefctr}}(n) \pmod{2}
    \end{aligned}
\end{equation}

\stepcounter{stddefctr}
\subsection{Definition \arabic{stddefctr} of \TotalOriginals\xspace -- Highest Bit Difference}

\note{This definition appears in \cite{Arndt_2010}}

\note{The text below is from Wiki and needs to be entirely rewritten. I was able to derive the formula on my own from translating their code. This method leads to a fast method for computing the Thue–Morse sequence: start with t0 = 0, and then, for each n, find the highest-order bit in the binary representation of n that is different from the same bit in the representation of n - 1. If this bit is at an even index, tn differs from tn - 1, and otherwise it is the same as tn - 1.}

\noindent\begin{minipage}[H]{0.48\textwidth}\begin{lstlisting}[style=pythonstyle]
from itertools import count

def p2_d07():
    value = 1
    for n in count():
        # Assumes that (-1).bit_length() == 1
        x = (n ^ (n - 1)).bit_length() + 1
        if x & 1 == 0:
            # Bit index even, so toggle value
            value = 1 - value
        yield value
\end{lstlisting}\end{minipage}

\note{Should there be a +1 inside that call to log2?}

\begin{equation}
    \edef\tempLabel{eq:p2_d\arabic{stddefctr}}
    \label{\tempLabel}
    \begin{aligned}
T_{2,\arabic{stddefctr}}(0) &= 0 \\
T_{2,\arabic{stddefctr}}(n) &= \begin{aligned}[c]
    &\floor{\log_2(n \oplus (n - 1))} \\
    &+ T_{2,\arabic{stddefctr}}(n - 1) \pm 1
\end{aligned} \pmod{2}
    \end{aligned}
\end{equation}

\stepcounter{stddefctr}
\subsection{Definition \arabic{stddefctr} -- Floor-Ceiling Difference}

\note{Appears in \cite{OEIS-TMS}}

\begin{equation}
    \edef\tempLabel{eq:p2_d\arabic{stddefctr}}
    \label{\tempLabel}
    \begin{aligned}
      b(n) &= \begin{cases}
          &n \quad \text{if } n \le 1 \\
          &b\left(\ceil{\dfrac{n}{2}}\right) - b\left(\floor{\dfrac{n}{2}}\right) \quad \text{otherwise}
\end{cases} \\
T_{2,\arabic{stddefctr}}(n) &= \dfrac{1 - b(2n)}{2} \pmod{2}
    \end{aligned}
\end{equation}

\note{This seems very similar to the highest bit difference definition, and I think it may be what that was derived from}

\stepcounter{stddefctr}
\subsection{Definition \arabic{stddefctr} -- Odious Number Derivation}

\note{Definition appears in \cite{OEIS-TMS}}

Another way to generate the \TMS is to take the sequence of Odious Numbers \cite{OEIS-Odious} mod $2$. Odious numbers are those with an odd number of $1$s in their binary representation. Note that the player numbers in this derivation are swapped, so when generating this for testing and extension, we add 1 to the result. Some simple generating code \cite{repo} for this is as follows:

\noindent\begin{minipage}[H]{0.48\textwidth}\begin{lstlisting}[style=pythonstyle]
from itertools import count

def seq_p2_d09():
    for i in count():
        if i.bit_count() & 1:
            yield (i + 1) & 1
\end{lstlisting}\end{minipage}

\begin{equation}
\edef\tempLabel{eq:p2_d\arabic{stddefctr}}
\label{\tempLabel}
T_{2,\arabic{stddefctr}}(n) = \text{Odious}(n) + 1 \pmod{2}
\end{equation}

\note{Aren't Odious Numbers exactly the numbers where the parity of the hamming weight is 1? So doesn't that mean that the Thue-Morse Sequence selects which numbers are Odious? From cursory testing, it seems to. There's something to be had there.}

\note{A possible way to extend this would be to reinterpret this as where the digit sum is not n-even}

\note{A related definition on OEIS \cite{OEIS-TMS} is
\begin{equation*}
\begin{aligned}
    &T(n) + \text{Odious}(n - 1) + 1 = 2n \text{ for } n \ge 1 \\
    &T(n) = 2n - \text{Odious}(n - 1) - 1
\end{aligned}
\end{equation*}
}

\stepcounter{stddefctr}
\subsection{Definition \arabic{stddefctr} -- Evil Numbers Derivation 1}

\note{Appears in \cite{OEIS-TMS}}

The Evil Numbers \cite{OEIS-Evil} are those who have an even number of $1$s in their binary representation. Note that this is the opposite of the Odious Numbers referenced above.

\noindent\begin{minipage}[H]{0.48\textwidth}\begin{lstlisting}[style=pythonstyle]
from itertools import count

def evil():
    for i in count():
        if i.bit_count() & 1 == 0:
            yield i

def p2_d10():
    for n, i in enumerate(evil()):
        yield (i - 2 * n) & 1
\end{lstlisting}\end{minipage}

\begin{equation}
\edef\tempLabel{eq:p2_d\arabic{stddefctr}}
\label{\tempLabel}
T_{2,\arabic{stddefctr}}(n) = \text{Evil}(n) - 2n \pmod{2}
\end{equation}

\stepcounter{stddefctr}
\subsection{Definition \arabic{stddefctr} -- Evil Numbers Derivation 2}

\note{Appears in \cite{OEIS-TMS-inv}}

A second, more-efficient derivation from the Evil Numbers is as follows, where $ce()$ is the count of Evil Numbers less than $n$ \cite{OEIS-A159481}, and $p()$ is the function defined in Equation \ref{eq:p2_d1}.

\begin{equation}
    \edef\tempLabel{eq:p2_d\arabic{stddefctr}}
    \label{\tempLabel}
    \begin{aligned}
     ce(n) &= \floor{\dfrac{n + 1}{2}} + p(n + 1) \cdot (n + 1 \mod{2}) \\
T_{2,\arabic{stddefctr}}(n) &= 1 - ce(n + 1) + ce(n)
    \end{aligned}
\end{equation}

\stepcounter{stddefctr}
\subsection{Definition \arabic{stddefctr} -- Odious \& Evil Numbers Derivation}

\note{Appears in \cite{OEIS-TMS-inv}}

A second, more-efficient derivation from the Evil Numbers is as follows, where $ce()$ is the count of Evil Numbers less than $n$ \cite{OEIS-A159481}, and $p()$ is the function defined in Equation \ref{eq:p2_d1}.

\begin{equation}
    \edef\tempLabel{eq:p2_d\arabic{stddefctr}}
    \label{\tempLabel}
    \begin{aligned}
     oe(n) &= \begin{cases}
         &\text{Odious}\left(\floor{\dfrac{n}{2}}\right) \quad \text{if } n \mod{2} = 0 \\
         &\text{Evil}\left(\floor{\dfrac{n}{2}}\right) \quad\quad\; \text{if } n \mod{2} = 1
     \end{cases} \\
T_{2,\arabic{stddefctr}}(n) &= 1 - oe(n) \pmod{2}
    \end{aligned}
\end{equation}

\stepcounter{stddefctr}
\subsection{Definition \arabic{stddefctr} -- Gould's Sequence Derivation}

\note{Appears in \cite{OEIS-TMS}}

Gould's Sequence \cite{OEIS-Gould} are the number of odd entries in a given row of Pascal's Triangle. Note that this is by far the least computationally efficient definition in this paper (see Tables \ref{tab:time_p2_d12} \& \ref{tab:space_p2_d12}).

\note{Why mod 3? Everything else is mod 2. This definition is unlikely to be extendable, unless you interpret this as the hamming weight of a given row, and extend the idea of hamming weight to those other bases. If so, I predict that the final mod is mod $(n + 1)$}

\begin{equation}
    \edef\tempLabel{eq:p2_d\arabic{stddefctr}}
    \label{\tempLabel}
    \begin{aligned}
T_{2,\arabic{stddefctr}}(n) &= \text{Gould}(n) - 1 \mod{3} \\
            &= \left(\sum_{k=0}^n \left(\binom{n}{k} \mod{2} \right)\right) - 1 \mod{3}
    \end{aligned}
\end{equation}

\stepcounter{stddefctr}
\subsection{Definition \arabic{stddefctr} -- Derivation from Blue Code}

\note{Appears in \cite{OEIS-TMS}}

In the OEIS, this sequence \cite{OEIS-A193231} is defined as the "binary coding of a polynomial over GF(2), substitute x+1 for x". There are a number of ways to generate it. One of the more computationally-accessible ones is:

\note{I strongly suspect I have translated this incorrectly. See code for canonical version}

\begin{equation}
    \edef\tempLabel{eq:p2_d\arabic{stddefctr}}
    \label{\tempLabel}
    \begin{aligned}
\text{A001317}(n) &= \sum_{k=0}^n \left(\binom{n}{k} \mod{2} \right) \cdot 2^k \\
\text{A193231}(n) &= \bigoplus_{i=0}^{\ceil{\log_2(n)}} \hspace{-5pt} \text{A001317}\left(i \cdot \floor{\dfrac{n \mod{2}}{2^i}}\right) \\
      T_{2,\arabic{stddefctr}}(n) &= \text{A193231}(n) \pmod{2}
    \end{aligned}
\end{equation}

Translated into words, this function computes the value of Sierpiński's triangle for the index of each high bit, then takes the bitwise exclusive or of all such resulting values. Note that since $\text{A001317}(0) = 0$, each low bit can be simplified out when calculating.

\note{It seems to me that this might be extendable by using GF(n) instead of GF(2), though I don't know of a way to efficient compute or prove such a result}

\subsection{Summary}

\section{Proving Equivalence Between Standard Definitions}

\subsection{Correlating Definition 1 and Definition 6}

Note that in Equation \ref{eq:p2_d6} where we define $T_{2,6}$, we are working in mod 2, where $+1$ and $-1$ are logically equivalent. We can therefore simplify its definition to be:

\begin{equation}
    \label{eq:p2d06s}
    \begin{aligned}
T_{2,6}(0) &= 0 \\
T_{2,6}(n) &= n + T_{2,6}\left(\floor{\dfrac{n}{2}}\right) \pmod{2}
    \end{aligned}
\end{equation}

This is identical to Equation \ref{eq:p2_d1}, where we define $T_{2,1}$.

\section{The Extensions}

\subsection{Extension \arabic{extdefctr} of \TotalExtensions\xspace -- Modular Digit Sums}

\note{Definition appears in \cite{Astudillo_2003, Dekking_2023, OEIS-TMS-3-2}}

To extend definition 1 from $2$ to $n$ players, we must first map our concept of parity to base n. We can do this by taking the parity equation defined above and replacing the $2$s with $n$, for $n \in \Integers_{\ge 2}$.

\begin{equation}
    \begin{aligned}
p_n(0) &= 0 \\
p_n(x) &= x + p_n\left(\floor{\dfrac{x}{n}}\right) \pmod{n}
    \end{aligned}
\end{equation}

Under this definition, you can construct the \TMS using the following, starting at 0:

\begin{equation}
    \edef\tempLabel{eq:pn_d\arabic{extdefctr}}
    \label{\tempLabel}
    T_{n,\arabic{extdefctr}}(x, s) = p_s(x)
\end{equation}

Note that this definition is trivially extensible to non-integer bases, though that is beyond the scope of this paper.

\subsubsection{Proof of Equivalence with Original Definition \arabic{extdefctr}}

It is clear from visual inspection that $p_2$ is identical to our original definition of $p$.

\begin{equation}
    \begin{aligned}
                                                           p_2(x) &= p(x) \\
                         x + p_2\left(\floor{\dfrac{x}{2}}\right) &= x + p\left(\floor{\dfrac{x}{2}}\right) \\
x + \floor{\dfrac{x}{2}} + p_2\left(\floor{\dfrac{x}{2^2}}\right) &= x + \floor{\dfrac{x}{2}} + p\left(\floor{\dfrac{x}{2^2}}\right) \\
       x + \floor{\dfrac{x}{2}} + \floor{\dfrac{x}{2^2}} + \ldots &= x + \floor{\dfrac{x}{2}} + \floor{\dfrac{x}{2^2}} + \ldots
    \end{aligned}
\end{equation}

\stepcounter{extdefctr}
\subsection{Extended Definition \arabic{extdefctr} of \TotalExtensions\xspace -- Roots of Unity}

\begin{equation}
    \edef\tempLabel{eq:pn_d\arabic{extdefctr}}
    \label{\tempLabel}
    \begin{aligned}
    f(x) &= k \text{ where } \omega^k = x \text{ and } \omega^s = 1 \\
T_{n,\arabic{extdefctr}}(n) &= f\left(\omega^{p(n)}\right)
    \end{aligned}
\end{equation}

\subsubsection{Proof of Equivalence with Original Definition \arabic{extdefctr}}

\stepcounter{extdefctr}
\subsection{Extended Definition \arabic{extdefctr} of \TotalExtensions\xspace -- Increment and Extend}

In the original version of this definition, we inverted the elements. In base $2$, this is the same thing as adding $1$ (mod $2$). Given that, let $t(x, n)$ be the first $n^x$ elements of the \ETMS, for $n \in \Integers_{\ge 2}$.

\begin{equation}
    \text{inc}(\mathbf{x}, n) = \begin{aligned}[c]
            &x_i + 1 \pmod{n} \\
            &\text{for } \mathbf{x} = (x_0, x_1, \ldots, x_{n-1})
    \end{aligned}
\end{equation}

\begin{equation}
    \begin{aligned}
t(0, n) &= \tuple{0} \\
t(1, n) &= \tuple{0, 1, \ldots, n - 1} \\
t(x, n) &= t(x - 1, n) \cdot \text{inc}(t(x - 1, n), n)
    \end{aligned}
\end{equation}

Given the above, we can define a recurrence relation that will give us individual elements. It will be less efficient to compute, but will allow proofs of equivalence to be easier.

\begin{equation}
    \edef\tempLabel{eq:pn_d\arabic{extdefctr}}
    \label{\tempLabel}
    \begin{aligned}
T_{n,\arabic{extdefctr}}(0, s) &= 0 \\
T_{n,\arabic{extdefctr}}(x, s) &= T_{n,\arabic{extdefctr}}\left(x - s^{\floor{\log_s(x)}}, s\right) + 1 \pmod{s}
    \end{aligned}
\end{equation}

\subsubsection{Proof of Equivalence with Original Definition 2}

\stepcounter{extdefctr}
\subsection{Extended Definition \arabic{extdefctr} of \TotalExtensions\xspace -- Substitute and Flatten}

\note{There's a bit of a leap here, since we have to explain why the rotation is equivalent to the binary choice presented in the original. There also might be a better syntax to define the rotation, perhaps using the format used in inv and inc.}

\begin{equation}
    \edef\tempLabel{eq:pn_d\arabic{extdefctr}}
    \label{\tempLabel}
    \begin{aligned}
            b(s) &= \tuple{0, 1, \cdots, s - 2, s - 1} \\
r(\mathbf{x}, i) &= \begin{aligned}[c]
                   &\tuple{x_{0 + i \mod{|\mathbf{x}|}}, x_{1 + i \mod{|\mathbf{x}|}}, \ldots} \\
                   &\text{for } \mathbf{x} = \tuple{x_0, x_1, \ldots, x_{n-1}}
        \end{aligned} \\
         s(x, s) &= r(b(s), x) \\
            t(0) &= \tuple{0} \\
         t(x, s) &= \bigparallel_{i=0}^{2^{x-1}-1} s(t(x-1)_i, s)  \\
   T_{n,\arabic{extdefctr}}(x, s) &= t(\ceil{\log_s(x + 1)}, s)_x
    \end{aligned}
\end{equation}

\subsubsection{Proof of Equivalence with Original Definition \arabic{extdefctr}}

\stepcounter{extdefctr}
\subsection{Extended Definition \arabic{extdefctr} of \TotalExtensions\xspace -- Recursive Rotation}

\begin{equation}
    \edef\tempLabel{eq:pn_d\arabic{extdefctr}}
    \label{\tempLabel}
    \begin{aligned}
r(\mathbf{x}, i) &= \begin{aligned}[c]
                   &\tuple{x_{0 + i \mod{|\mathbf{x}|}}, x_{1 + i \mod{|\mathbf{x}|}}, \ldots} \\
                   &\text{for } \mathbf{x} = \tuple{x_0, x_1, \ldots, x_{n-1}}
        \end{aligned} \\
         t(0, s) &= \tuple{0} \\
         t(1, s) &= \tuple{0, 1, \ldots, s - 1} \\
         t(x, s) &= \bigparallel_{i=0}^{s-1} r\left(t(x-1, s), i \cdot s^{x-2}\right) \\
   T_{n,\arabic{extdefctr}}(x, s) &= t(\ceil{\log_s(x + 1)}, s)_x
    \end{aligned}
\end{equation}

\subsubsection{Proof of Equivalence with Original Definition \arabic{extdefctr}}

\stepcounter{extdefctr}
\subsection{Extended Definition \arabic{extdefctr} of \TotalExtensions\xspace -- Recursion}

\note{Need to reference eq \ref{eq:p2d06s} in definition}

\subsubsection{Proof of Equivalence with Original Definition \arabic{extdefctr}}

\stepcounter{extdefctr}
\subsection{Extended Definition \arabic{extdefctr} of \TotalExtensions\xspace -- Highest Digit Difference}

\begin{equation}
    \edef\tempLabel{eq:pn_d\arabic{extdefctr}}
    \label{\tempLabel}
    \begin{aligned}
\text{XOR}_{n}(a, b) &= \hspace{-13pt} \sum_{i=0}^{\ceil{\log_{n}(\max(a,b) + 1)}} \hspace{-15pt} n^i \left(\floor{\dfrac{a}{n^i}} - \floor{\dfrac{b}{n^i}} \mod{n}\right) \\
       T_{n,\arabic{extdefctr}}(0, s) &= 0 \\
       T_{n,\arabic{extdefctr}}(x, s) &= \begin{aligned}[c]
           &\floor{\log_s(\text{XOR}_{s}(x, x - 1))} \\
           &+ T_{n,\arabic{extdefctr}}(x - 1, s) + 1
       \end{aligned} \pmod{s}
    \end{aligned}
\end{equation}

\note{Substitute n for 2, then simplify, plus a bit}

\subsubsection{Proof of Equivalence with Original Definition \arabic{extdefctr}}

\subsection{Summary}

\section{Proving Equivalence Between Extended Definitions}

\subsection{Summary}

\section{Proving Persistence (Or Lack Thereof) of Original Properties}

\subsection{Use as a Fair-Share Sequence}

\subsection{Aperiodicity}

\subsection{Palindrome}

\subsection{Uniform Recurrence}

\note{The Thue–Morse sequence is a uniformly recurrent word: given any finite string X in the sequence, there is some length nX (often much longer than the length of X) such that X appears in every block of length nX}

\section{Acknowledgment}

The preferred spelling of the word ``acknowledgment'' in America is without 
an ``e'' after the ``g''. Avoid the stilted expression ``one of us (R. B. 
G.) thanks $\ldots$''. Instead, try ``R. B. G. thanks$\ldots$''. Put sponsor 
acknowledgments in the unnumbered footnote on the first page.

\section{Appendix}

\setcounter{stddefctr}{1}
\setcounter{extdefctr}{1}

\subsection{Complexity of Original Definition \arabic{stddefctr}}
\edef\tempLabel{ca:p2_d\arabic{stddefctr}}
\expandafter\label\expandafter\tempLabel

\subsubsection{Time Complexity}

In an idealized case, this definition will simplify to:

\begin{equation}
T_{2,\arabic{stddefctr}}(n) = \left(\sum_{i=0}^{\ceil{\log_2(n + 1)}} \hspace{-8pt} \floor{\dfrac{n}{2^i} \mod{2}} \right) \mod{2}
\end{equation}

This is pretty explicitly $O(\log(n))$ operations. This means that generating the first $n$ entries will take $O(n\log(n))$ operations.

In languages with dynamically sized integers, this can be slightly more complicated. In the above, we perform $\log(n)$ bit shifts, multiplications, moduli, and additions. Since a bit shift is constant time, calculation will be dominated by multiplication, division, and moduli. Each of these take $O(\log(n) \cdot \log(\log(n)))$, where $n$ is the largest number involved. This means that in such languages, we can expect it to take $O(\log(n)^2 \cdot \log(\log(n)))$ operations per element, for $O(n \cdot \log(n)^2 \cdot \log(\log(n)))$ in total.

\renewcommand{\arraystretch}{1.25}
\begin{table}[H]
    \centering
    \caption{Time Complexity Summary of Standard Definition \arabic{stddefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} & $O(\log(n))$ & $O(\log(n)^2 \cdot \log(\log(n)))$ \\
        \hline
        \textbf{In Total} & $O(n \cdot \log(n))$ & $O(n \cdot \log(n)^2 \cdot \log(\log(n)))$ \\
        \hline
    \end{tabular}
    \edef\tempLabel{tab:time_p2_d\arabic{stddefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}
\renewcommand{\arraystretch}{1}

\subsubsection{Space Complexity}

This is one of the more space-efficient implementations. Each element takes at most the same size as the passed integer. In languages that use Fixed Size integers, that means it will take $O(1)$ space. In languages like Python that use Arbitrary Size integers, it would take $O(\log(n))$ space, where $n$ is the largest element you intend to calculate. If you intend to store all $n$ elements, it will therefore take $O(n)$ or $O(n \cdot \log(n))$ space.

\begin{table}[H]
    \centering
    \caption{Space Complexity Summary of Standard Definition \arabic{stddefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} & $O(1)$ & $O(\log(n))$ \\
        \hline
        \textbf{In Total} & $O(n)$ & $O(n \cdot \log(n))$ \\
        \hline
    \end{tabular}
    \edef\tempLabel{tab:space_p2_d\arabic{stddefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\stepcounter{stddefctr}
\subsection{Complexity of Original Definition \arabic{stddefctr}}
\edef\tempLabel{ca:p2_d\arabic{stddefctr}}
 \expandafter\label\expandafter\tempLabel

\subsubsection{Time Complexity}

\begin{table}[H]
    \centering
    \caption{Time Complexity Summary of Standard Definition \arabic{stddefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} &  &  \\
        \hline
        \textbf{In Total} &  &  \\
        \hline
    \end{tabular}
    \edef\tempLabel{tab:time_p2_d\arabic{stddefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\subsubsection{Space Complexity}

\begin{table}[H]
    \centering
    \caption{Space Complexity Summary of Standard Definition \arabic{stddefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} &  &  \\
        \hline
        \textbf{In Total} &  &  \\
        \hline
    \end{tabular}
    \edef\tempLabel{tab:space_p2_d\arabic{stddefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\stepcounter{stddefctr}
\subsection{Complexity of Original Definition \arabic{stddefctr}}
\edef\tempLabel{ca:p2_d\arabic{stddefctr}}
 \expandafter\label\expandafter\tempLabel

\subsubsection{Time Complexity}

\begin{table}[H]
    \centering
    \caption{Time Complexity Summary of Standard Definition \arabic{stddefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} &  &  \\
        \hline
        \textbf{In Total} &  &  \\
        \hline
    \end{tabular}
    \edef\tempLabel{tab:time_p2_d\arabic{stddefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\subsubsection{Space Complexity}

\begin{table}[H]
    \centering
    \caption{Space Complexity Summary of Standard Definition \arabic{stddefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} &  &  \\
        \hline
        \textbf{In Total} &  &  \\
        \hline
    \end{tabular}
    \edef\tempLabel{tab:space_p2_d\arabic{stddefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\stepcounter{stddefctr}
\subsection{Complexity of Original Definition \arabic{stddefctr}}
\edef\tempLabel{ca:p2_d\arabic{stddefctr}}
 \expandafter\label\expandafter\tempLabel

\subsubsection{Time Complexity}

\begin{table}[H]
    \centering
    \caption{Time Complexity Summary of Standard Definition \arabic{stddefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} &  &  \\
        \hline
        \textbf{In Total} &  &  \\
        \hline
    \end{tabular}
    \edef\tempLabel{tab:time_p2_d\arabic{stddefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\subsubsection{Space Complexity}

\begin{table}[H]
    \centering
    \caption{Space Complexity Summary of Standard Definition \arabic{stddefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} &  &  \\
        \hline
        \textbf{In Total} &  &  \\
        \hline
    \end{tabular}
    \edef\tempLabel{tab:space_p2_d\arabic{stddefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\stepcounter{stddefctr}
\subsection{Complexity of Original Definition \arabic{stddefctr}}
\edef\tempLabel{ca:p2_d\arabic{stddefctr}}
 \expandafter\label\expandafter\tempLabel

\subsubsection{Time Complexity}

\begin{table}[H]
    \centering
    \caption{Time Complexity Summary of Standard Definition \arabic{stddefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} &  &  \\
        \hline
        \textbf{In Total} &  &  \\
        \hline
    \end{tabular}
    \edef\tempLabel{tab:time_p2_d\arabic{stddefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\subsubsection{Space Complexity}

\begin{table}[H]
    \centering
    \caption{Space Complexity Summary of Standard Definition \arabic{stddefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} &  &  \\
        \hline
        \textbf{In Total} &  &  \\
        \hline
    \end{tabular}
    \edef\tempLabel{tab:space_p2_d\arabic{stddefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\stepcounter{stddefctr}
\subsection{Complexity of Original Definition \arabic{stddefctr}}
\edef\tempLabel{ca:p2_d\arabic{stddefctr}}
 \expandafter\label\expandafter\tempLabel

\subsubsection{Time Complexity}

At each step in calculation, the value of $n$ passed to the next recursion is halved. This means that it will take $O(\log_2(n))$ recursive steps. Each recursion involves at maximum 2 subtractions and a bit shift. In most languages with Fixed Size integers, this will take constant time. However, in languages with Arbitrary Size integers these subtractions will typically take $O(\log(n))$, where $n$ is the largest integer in the operation. This means we can expect it to take $O(\log(n)^2$ operations.

\renewcommand{\arraystretch}{1.25}
\begin{table}[H]
    \centering
    \caption{Time Complexity Summary of Standard Definition \arabic{stddefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} & $O(\log(n))$ & $O(\log(n)^2)$ \\
        \hline
        \textbf{In Total} & $O(n \cdot \log(n))$ & $O(n \cdot \log(n)^2)$ \\
        \hline
    \end{tabular}
    \edef\tempLabel{tab:time_p2_d\arabic{stddefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}
\renewcommand{\arraystretch}{1}

\subsubsection{Space Complexity}

This is one of the more space-efficient implementations. Each element takes at most the same size as the passed integer. In languages that use Fixed Size integers, that means it will take $O(1)$ space. In languages like Python that use Arbitrary Size integers, it would take $O(\log(n))$ space, where $n$ is the largest element you intend to calculate. If you intend to store all $n$ elements, it will therefore take $O(n)$ or $O(n \cdot \log(n))$ space.

\begin{table}[H]
    \centering
    \caption{Space Complexity Summary of Standard Definition \arabic{stddefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} & $O(1)$ & $O(\log(n))$ \\
        \hline
        \textbf{In Total} & $O(n)$ & $O(n \cdot \log(n))$ \\
        \hline
    \end{tabular}
    \edef\tempLabel{tab:space_p2_d\arabic{stddefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\stepcounter{stddefctr}
\subsection{Complexity of Original Definition \arabic{stddefctr}}
\edef\tempLabel{ca:p2_d\arabic{stddefctr}}
 \expandafter\label\expandafter\tempLabel

\subsubsection{Time Complexity}

\note{Since this algorithm works sequentially, and cannot perform computation of an arbitrary element without recursing to the base case, the time is equal on a per-element and in-total basis}

\renewcommand{\arraystretch}{1.25}
\begin{table}[H]
    \centering
    \caption{Time Complexity Summary of Standard Definition \arabic{stddefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} & $O(n \cdot \log(n))$ & $O\left(n \cdot \log(n)^2\right)$ \\
        \hline
        \textbf{In Total} & $O(n \cdot \log(n))$ & $O\left(n \cdot \log(n)^2\right)$ \\
        \hline
    \end{tabular}
    \edef\tempLabel{tab:time_p2_d\arabic{stddefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}
\renewcommand{\arraystretch}{1}

\subsubsection{Space Complexity}

\begin{table}[H]
    \centering
    \caption{Space Complexity Summary of Standard Definition \arabic{stddefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} & $O(1)$ & $O(\log(n))$ \\
        \hline
        \textbf{In Total} & $O(n)$ & $O(n \cdot \log(n))$ \\
        \hline
    \end{tabular}
    \edef\tempLabel{tab:space_p2_d\arabic{stddefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\stepcounter{stddefctr}
\subsection{Complexity of Original Definition \arabic{stddefctr}}
\edef\tempLabel{ca:p2_d\arabic{stddefctr}}
 \expandafter\label\expandafter\tempLabel

\subsubsection{Time Complexity}

\note{memoization doesn't seem to help in the worst case of $1\ldots1_2$, so you should still end up calculating the value of $b()$ for every positive number less than $n$}

\renewcommand{\arraystretch}{1.25}
\begin{table}[H]
    \centering
    \caption{Time Complexity Summary of Standard Definition \arabic{stddefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} & $O(n)$ & $O(n \cdot \log(n) \cdot \log(\log(n)))$ \\
        \hline
        \textbf{In Total} & $O\left(n^2\right)$ & $O\left(n^2 \cdot \log(n) \cdot \log(\log(n))\right)$ \\
        \hline
    \end{tabular}
    \edef\tempLabel{tab:time_p2_d\arabic{stddefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\subsubsection{Space Complexity}

There are two ways to implement this algorithm in terms of space complexity. They both have equal worst-case time complexity. The first is to take the recursive approach, and the second is to use dynamic programming.

In a recursive approach, you will end up descending $O(\log(n))$ stack frames, each of which will contain at minimum 1 integer. In the dynamic approach, you will keep a table of all the values of $b()$ from $0$ through $n$. The biggest difference between these approaches is that in the recursive approach you may need to repeat calculations.

\begin{table}[H]
    \centering
    \caption{Space Complexity Summary of Standard Definition \arabic{stddefctr}}
    \begin{tabular}{|cc|c|c|}
        \hline
        & & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \multirow{2}{*}{\textbf{Recursive}} \hspace{-5pt} & \textbf{Per Element} & $O(\log(n))$ & $O(n \cdot \log(n))$ \\
        \cline{2-4}
        & \textbf{In Total} & $O(n \cdot \log(n))$ & $O\left(n^2 \cdot \log(n)\right)$ \\
        \hline
        \multirow{2}{*}{\textbf{Dynamic}} \hspace{-5pt} & \textbf{Per Element} & $O(n)$ & $O(n \cdot \log(n))$ \\
        \cline{2-4}
        & \textbf{In Total} & $O\left(n^2\right)$ & $O\left(n^2 \cdot \log(n)\right)$ \\
        \hline
    \end{tabular}
    \edef\tempLabel{tab:space_p2_d\arabic{stddefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}
\renewcommand{\arraystretch}{1}

\stepcounter{stddefctr}
\subsection{Complexity of Original Definition \arabic{stddefctr}}
\edef\tempLabel{ca:p2_d\arabic{stddefctr}}
 \expandafter\label\expandafter\tempLabel

\subsubsection{Time Complexity}

\begin{table}[H]
    \centering
    \caption{Time Complexity Summary of Standard Definition \arabic{stddefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} &  &  \\
        \hline
        \textbf{In Total} &  &  \\
        \hline
    \end{tabular}
    \edef\tempLabel{tab:time_p2_d\arabic{stddefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\subsubsection{Space Complexity}

\begin{table}[H]
    \centering
    \caption{Space Complexity Summary of Standard Definition \arabic{stddefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} &  &  \\
        \hline
        \textbf{In Total} &  &  \\
        \hline
    \end{tabular}
    \edef\tempLabel{tab:space_p2_d\arabic{stddefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\stepcounter{stddefctr}
\subsection{Complexity of Original Definition \arabic{stddefctr}}
\edef\tempLabel{ca:p2_d\arabic{stddefctr}}
 \expandafter\label\expandafter\tempLabel

\subsubsection{Time Complexity}

\begin{table}[H]
    \centering
    \caption{Time Complexity Summary of Standard Definition \arabic{stddefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} &  &  \\
        \hline
        \textbf{In Total} &  &  \\
        \hline
    \end{tabular}
    \edef\tempLabel{tab:time_p2_d\arabic{stddefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\subsubsection{Space Complexity}

\begin{table}[H]
    \centering
    \caption{Space Complexity Summary of Standard Definition \arabic{stddefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} &  &  \\
        \hline
        \textbf{In Total} &  &  \\
        \hline
    \end{tabular}
    \edef\tempLabel{tab:space_p2_d\arabic{stddefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\stepcounter{stddefctr}
\subsection{Complexity of Original Definition \arabic{stddefctr}}
\edef\tempLabel{ca:p2_d\arabic{stddefctr}}
 \expandafter\label\expandafter\tempLabel

\subsubsection{Time Complexity}

\begin{table}[H]
    \centering
    \caption{Time Complexity Summary of Standard Definition \arabic{stddefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} &  &  \\
        \hline
        \textbf{In Total} &  &  \\
        \hline
    \end{tabular}
    \edef\tempLabel{tab:time_p2_d\arabic{stddefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\subsubsection{Space Complexity}

\begin{table}[H]
    \centering
    \caption{Space Complexity Summary of Standard Definition \arabic{stddefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} &  &  \\
        \hline
        \textbf{In Total} &  &  \\
        \hline
    \end{tabular}
    \edef\tempLabel{tab:space_p2_d\arabic{stddefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\stepcounter{stddefctr}
\subsection{Complexity of Original Definition \arabic{stddefctr}}
\edef\tempLabel{ca:p2_d\arabic{stddefctr}}
 \expandafter\label\expandafter\tempLabel

\subsubsection{Time Complexity}

\begin{table}[H]
    \centering
    \caption{Time Complexity Summary of Standard Definition \arabic{stddefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} &  &  \\
        \hline
        \textbf{In Total} &  &  \\
        \hline
    \end{tabular}
    \edef\tempLabel{tab:time_p2_d\arabic{stddefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\subsubsection{Space Complexity}

\begin{table}[H]
    \centering
    \caption{Space Complexity Summary of Standard Definition \arabic{stddefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} &  &  \\
        \hline
        \textbf{In Total} &  &  \\
        \hline
    \end{tabular}
    \edef\tempLabel{tab:space_p2_d\arabic{stddefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\stepcounter{stddefctr}
\subsection{Complexity of Original Definition \arabic{stddefctr}}
\edef\tempLabel{ca:p2_d\arabic{stddefctr}}
 \expandafter\label\expandafter\tempLabel

\subsubsection{Time Complexity}

There are two ways one could reasonably calculate this. The first is by building each row of Pascal's Triangle iteratively. This allows you to avoid multiplication whenever possible, and lets you apply a bitmask or modulus operation to take the parity of each entry. The downside is that this version is not parallelizable. Using the bit mask approach, this means that each entry will take $O(n)$ time.

The other is to take advantage of the relation $\binom{n}{k} = \binom{n}{k-1} \cdot \dfrac{n - (k - 1)}{k}$. This allows you to calculate each row independently, using $\tfrac{n}{2}$ moduli, multiplications, and divisions. This means that each entry will take $O(n)$ operations, each of which take $O(\log(n) \cdot \log(\log(n)))$ if with arbitrary sized integers, totaling $O(n)$ or $O(n \cdot \log(n) \cdot \log(\log(n)))$.

\renewcommand{\arraystretch}{1.25}
\begin{table}[H]
    \centering
    \caption{Time Complexity Summary of Standard Definition \arabic{stddefctr}}
    \begin{tabular}{|cc|c|c|}
        \hline
        & & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \multirow{2}{*}{\textbf{Serial}} \hspace{-5pt} & \textbf{Per Element} & $O(n)$ & $O(n)$ \\
        \cline{2-4}
        & \textbf{In Total} & $O\left(n^2\right)$ & $O\left(n^2\right)$ \\
        \hline
        \multirow{2}{*}{\textbf{Parallel}} \hspace{-5pt} & \textbf{Per Element} & $O(n) $ & $O(n \cdot \log(n) \cdot \log(\log(n)))$ \\
        \cline{2-4}
        & \textbf{In Total} & $O\left(n^2\right) $ & $O\left(n^2 \cdot \log(n) \cdot \log(\log(n))\right)$ \\
        \hline
    \end{tabular}
    \edef\tempLabel{tab:time_p2_d\arabic{stddefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}


\subsubsection{Space Complexity}

\begin{table}[H]
    \centering
    \caption{Space Complexity Summary of Standard Definition \arabic{stddefctr}}
    \begin{tabular}{|cc|c|c|}
        \hline
        & & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \multirow{2}{*}{\textbf{Serial}} \hspace{-5pt} & \textbf{Per Element} & $O(n)$ & $O\left(n \cdot \log(n)\right)$ \\
        \cline{2-4}
        & \textbf{In Total} & $O\left(n^2\right)$ & $O\left(n^2 \cdot \log(n)\right)$ \\
        \hline
        \multirow{2}{*}{\textbf{Parallel}} \hspace{-5pt} & \textbf{Per Element} & $O(1)$ & $O\left(\log(n)\right)$ \\
        \cline{2-4}
        & \textbf{In Total} & $O(n)$ & $O\left(n \cdot \log(n)^2\right)$ \\
        \hline
    \end{tabular}
    \edef\tempLabel{tab:space_p2_d\arabic{stddefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}
\renewcommand{\arraystretch}{1}

\stepcounter{stddefctr}
\subsection{Complexity of Original Definition \arabic{stddefctr}}
\edef\tempLabel{ca:p2_d\arabic{stddefctr}}
 \expandafter\label\expandafter\tempLabel

\subsubsection{Time Complexity}

\begin{table}[H]
    \centering
    \caption{Time Complexity Summary of Standard Definition \arabic{stddefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} &  &  \\
        \hline
        \textbf{In Total} &  &  \\
        \hline
    \end{tabular}
    \edef\tempLabel{tab:time_p2_d\arabic{stddefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\subsubsection{Space Complexity}

\begin{table}[H]
    \centering
    \caption{Space Complexity Summary of Standard Definition \arabic{stddefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} &  &  \\
        \hline
        \textbf{In Total} &  &  \\
        \hline
    \end{tabular}
    \edef\tempLabel{tab:space_p2_d\arabic{stddefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\subsection{Complexity of Extension Definition \arabic{extdefctr}}
\edef\tempLabel{ca:pn_d\arabic{extdefctr}}
 \expandafter\label\expandafter\tempLabel

In an idealized case, this definition will simplify to:

\begin{equation}
T_{n,\arabic{extdefctr}}(x, s) = \left(\sum_{i=0}^{\ceil{\log_s(x + 1)}} \hspace{-8pt} \floor{\dfrac{x}{s^i} \mod{s}} \right) \mod{s}
\end{equation}

This is pretty explicitly $O(\log(n))$ operations. This means that generating the first $n$ entries will take $O(n\log(n))$ operations.

In languages with dynamically sized integers, this can be slightly more complicated. In the above, we perform $\log(n)$ multiplications, moduli, and additions. Since additions are simpler, calculation will be dominated by multiplication, division, and moduli. Each of these take $O(\log(n) \cdot \log(\log(n)))$, where $n$ is the largest number involved. This means that in such languages, we can expect it to take $O(\log(n)^2 \cdot \log(\log(n)))$ operations per element, for $O(n \cdot \log(n)^2 \cdot \log(\log(n)))$ in total.

\renewcommand{\arraystretch}{1.25}
\begin{table}[H]
    \centering
    \caption{Time Complexity Summary of Extended Definition \arabic{extdefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} & $O(\log(n))$ & $O(\log(n)^2 \cdot \log(\log(n)))$ \\
        \hline
        \textbf{In Total} & $O(n \cdot \log(n))$ & $O(n \cdot \log(n)^2 \cdot \log(\log(n)))$ \\
        \hline
    \end{tabular}
     \edef\tempLabel{tab:time_pn_d\arabic{extdefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}
\renewcommand{\arraystretch}{1}

\subsubsection{Space Complexity}

This is one of the more space-efficient implementation. Each element takes at most the same size as the passed integer. In languages that use Fixed Size integers, that means it will take $O(1)$ space. In languages like Python that use Arbitrary Size integers, it would take $O(\log(n))$ space, where $n$ is the largest element you intend to calculate. If you intend to store all $n$ elements, it will therefore take $O(n)$ or $O(n \cdot \log(n))$ space.

\begin{table}[H]
    \centering
    \caption{Space Complexity Summary of Extended Definition \arabic{extdefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} & $O(1)$ & $O(\log(n))$ \\
        \hline
        \textbf{In Total} & $O(n)$ & $O(n \cdot \log(n))$ \\
        \hline
    \end{tabular}
     \edef\tempLabel{tab:space_pn_d\arabic{extdefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\stepcounter{extdefctr}
\subsection{Complexity of Extension Definition \arabic{extdefctr}}
\edef\tempLabel{ca:pn_d\arabic{extdefctr}}
 \expandafter\label\expandafter\tempLabel

\subsubsection{Time Complexity}

\begin{table}[H]
    \centering
    \caption{Time Complexity Summary of Extended Definition \arabic{extdefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} &  &  \\
        \hline
        \textbf{In Total} &  &  \\
        \hline
    \end{tabular}
     \edef\tempLabel{tab:time_pn_d\arabic{extdefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\subsubsection{Space Complexity}

\begin{table}[H]
    \centering
    \caption{Space Complexity Summary of Extended Definition \arabic{extdefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} &  &  \\
        \hline
        \textbf{In Total} &  &  \\
        \hline
    \end{tabular}
     \edef\tempLabel{tab:space_pn_d\arabic{extdefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\stepcounter{extdefctr}
\subsection{Complexity of Extension Definition \arabic{extdefctr}}
\edef\tempLabel{ca:pn_d\arabic{extdefctr}}
 \expandafter\label\expandafter\tempLabel

\subsubsection{Time Complexity}

\begin{table}[H]
    \centering
    \caption{Time Complexity Summary of Extended Definition \arabic{extdefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} &  &  \\
        \hline
        \textbf{In Total} &  &  \\
        \hline
    \end{tabular}
     \edef\tempLabel{tab:time_pn_d\arabic{extdefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\subsubsection{Space Complexity}

\begin{table}[H]
    \centering
    \caption{Space Complexity Summary of Extended Definition \arabic{extdefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} &  &  \\
        \hline
        \textbf{In Total} &  &  \\
        \hline
    \end{tabular}
     \edef\tempLabel{tab:space_pn_d\arabic{extdefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\stepcounter{extdefctr}
\subsection{Complexity of Extension Definition \arabic{extdefctr}}
\edef\tempLabel{ca:pn_d\arabic{extdefctr}}
 \expandafter\label\expandafter\tempLabel

\subsubsection{Time Complexity}

\begin{table}[H]
    \centering
    \caption{Time Complexity Summary of Extended Definition \arabic{extdefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} &  &  \\
        \hline
        \textbf{In Total} &  &  \\
        \hline
    \end{tabular}
     \edef\tempLabel{tab:time_pn_d\arabic{extdefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\subsubsection{Space Complexity}

\begin{table}[H]
    \centering
    \caption{Space Complexity Summary of Extended Definition \arabic{extdefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} &  &  \\
        \hline
        \textbf{In Total} &  &  \\
        \hline
    \end{tabular}
     \edef\tempLabel{tab:space_pn_d\arabic{extdefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\stepcounter{extdefctr}
\subsection{Complexity of Extension Definition \arabic{extdefctr}}
\edef\tempLabel{ca:pn_d\arabic{extdefctr}}
 \expandafter\label\expandafter\tempLabel

\subsubsection{Time Complexity}

\begin{table}[H]
    \centering
    \caption{Time Complexity Summary of Extended Definition \arabic{extdefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} &  &  \\
        \hline
        \textbf{In Total} &  &  \\
        \hline
    \end{tabular}
     \edef\tempLabel{tab:time_pn_d\arabic{extdefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\subsubsection{Space Complexity}

\begin{table}[H]
    \centering
    \caption{Space Complexity Summary of Extended Definition \arabic{extdefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} &  &  \\
        \hline
        \textbf{In Total} &  &  \\
        \hline
    \end{tabular}
     \edef\tempLabel{tab:space_pn_d\arabic{extdefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\stepcounter{extdefctr}
\subsection{Complexity of Extension Definition \arabic{extdefctr}}
\edef\tempLabel{ca:pn_d\arabic{extdefctr}}
 \expandafter\label\expandafter\tempLabel

\subsubsection{Time Complexity}

At each step in calculation, the value of $n$ passed to the next recursion is divided by $s$ (the selected base). This means that it will take $O(\log_s(n))$ recursive steps. Each recursion involves at maximum 2 subtractions and a bit shift. In most languages with Fixed Size integers, this will take constant time. However, in languages with Arbitrary Size integers these subtractions will typically take $O(\log(n))$, where $n$ is the largest integer in the operation. This means we can expect it to take $O(\log(n)^2$ operations.

\renewcommand{\arraystretch}{1.25}
\begin{table}[H]
    \centering
    \caption{Time Complexity Summary of Extended Definition \arabic{extdefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} & $O(\log(n))$ & $O(\log(n)^2)$ \\
        \hline
        \textbf{In Total} & $O(n \cdot \log(n))$ & $O(n \cdot \log(n)^2)$ \\
        \hline
    \end{tabular}
     \edef\tempLabel{tab:time_pn_d\arabic{extdefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}
\renewcommand{\arraystretch}{1}

\subsubsection{Space Complexity}

This is one of the more space-efficient implementations. Each element takes at most the same size as the passed integer. In languages that use Fixed Size integers, that means it will take $O(1)$ space. In languages like Python that use Arbitrary Size integers, it would take $O(\log(n))$ space, where $n$ is the largest element you intend to calculate. If you intend to store all $n$ elements, it will therefore take $O(n)$ or $O(n \cdot \log(n))$ space.

\begin{table}[H]
    \centering
    \caption{Space Complexity Summary of Extended Definition \arabic{extdefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} & $O(1)$ & $O(\log(n))$ \\
        \hline
        \textbf{In Total} & $O(n)$ & $O(n \cdot \log(n))$ \\
        \hline
    \end{tabular}
     \edef\tempLabel{tab:space_pn_d\arabic{extdefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\stepcounter{extdefctr}
\subsection{Complexity of Extension Definition \arabic{extdefctr}}
\edef\tempLabel{ca:pn_d\arabic{extdefctr}}
 \expandafter\label\expandafter\tempLabel

\subsubsection{Time Complexity}

\renewcommand{\arraystretch}{1.25}
\begin{table}[H]
    \centering
    \caption{Time Complexity Summary of Extended Definition \arabic{extdefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} & $O(n \cdot \log(n))$ & $O\left(n \cdot \log(n)^2\right)$ \\
        \hline
        \textbf{In Total} & $O(n \cdot \log(n))$ & $O\left(n \cdot \log(n)^2\right)$ \\
        \hline
    \end{tabular}
     \edef\tempLabel{tab:time_pn_d\arabic{extdefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}
\renewcommand{\arraystretch}{1}

\subsubsection{Space Complexity}

\begin{table}[H]
    \centering
    \caption{Space Complexity Summary of Extended Definition \arabic{extdefctr}}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Fixed Size} & \textbf{Arbitrary Size} \\
        \hline
        \textbf{Per Element} & $O(1)$ & $O(\log(n))$ \\
        \hline
        \textbf{In Total} & $O(1)$ & $O(\log(n))$ \\
        \hline
    \end{tabular}
     \edef\tempLabel{tab:space_pn_d\arabic{extdefctr}}
     \expandafter\label\expandafter\tempLabel
\end{table}

\bibliographystyle{unsrt}
\bibliography{references}     % without the .bib extension

\onecolumn

\lstset{basicstyle=\ttfamily, breaklines=true}
\lstinputlisting{notes/definitions_to_add.txt}

\end{document}
